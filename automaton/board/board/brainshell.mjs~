
export default {} 

const  MNU_ADDCOMPONENT = 2048
const  MNU_MAXCOMPONENT = MNU_ADDCOMPONENT + 256

const  MNU_SIGMOID    = 1021

const  MNU_ZOOM       = 1010 // 0, 1, 2 used...
const  MNU_ENDZOOM    = 1020

const  MNU_CLOSE      = 1030
const  MNU_SYNAPSE    = 1009 
const  MNU_NEURON     = 1008
const  MNU_PROPERTIES = 1007
const  MNU_DELETE     = 1006
const  MNU_LOAD       = 1005
const  MNU_SAVE       = 1004        
const  MNU_RESET      = 1003               
const  MNU_RUN        = 1002
const  MNU_ADDNEURON  = 1001

const  MNU_ADD_INPUT_START  = 5000
const  MNU_ADD_OUTPUT_START = 6000
const  MNU_ADD_OUTPUT_LAST  = 6999

const  LST_NEWBOARD = 1000
const   BTN_CREATENAME = 1001

/*
PRELOAD( register_control_ids )
{
	SimpleRegisterResource( LST_NEWBOARD, LISTBOX_CONTROL_NAME );
	SimpleRegisterResource( BTN_CREATENAME, NORMAL_BUTTON_NAME );
}
*/
import * as peices from "./brain.peices.mjs";
import {DefaultMethods,DefaultViaMethods}  from "./peice.mjs";


//typedef class local_tag BRAINBOARD;

function outputInput( ) {
	
	return {
		flags : {
			 bOutput : 0 // else is an input...
		},
		brainboard : null,
		//PBRAIN_STEM pbs;
		brain : null, 
		conn : null, 
		neuron : null,  // this is what we really need... this particular peice's neural peice 
	};
	//typedef struct output_input_type OUTPUT_INPUT;
}


//static class BRAINBOARD *l;

export function BrainBoard( _brain, container ) {
	var flags = {
		bOwnBrain : false // allocated its own brain...
	} ;


	var create_input_type,create_output_type;

	// these are the peice sets which will be loaded
	// from the file at the moemnt...
	var NeuronPeice, InputPeice, OutputPeice, BackgroundPeice;
	var NervePeice;

	var brain;
	var DefaultSynapse;
	var DefaultNeuron;

	var hMenu, hMenuComponents;

	// although a PIVIA is-a PIPEICE, a via type peice is required
	// for certain operations such as beginpath.
	// this also results in certain interactions between peice instances
	// (peice methods such as connect, disconnect are performed)

	var background_methods; // these are created with board ID
	var neuron_methods;
	var input_methods;
	var output_methods;
	var nerve_methods;

	var connectors = [];
	var menus = [];

	var board;

		background_methods = BackgroundMethods(this);
		neuron_methods     = new NEURON_METHODS(this);
		input_methods      = new INPUT_METHODS(this);
		output_methods     = new OUTPUT_METHODS(this);
		nerve_methods      = new NERVE_METHODS(this);
		brain = _brain;
		Init();

	return {
			
	
		//---------------------------------------------------
        	
		FindPeiceMethods( type )
                {
			var methods = NULL;
	        	if( type === ("neuron") )
				methods =neuron_methods;
			else if( type === ("background") )
        			methods =background_methods;
			else if( type === ("nerve") )
	        		methods =nerve_methods;
			else if( type === ("input") )
        			methods =input_methods;
			else if(  type === ("output") )
                		methods =output_methods;
			if( methods && methods.master )
	        	{
				console.log( WIDE("Peice for methods is already defined... there is a tight relationship between a single graphic and these methods") );
				//return NULL;
        		}
			return methods;
	        },
		
		//---------------------------------------------------

                //---------------------------------------------------
		
        	
		BuildBrainstemMenus(  hMenuComponents,  pbs
	        						 , menus
								 , connectors, idx )
        	{
			{
                		var n = 0;
				//PBRAIN_STEM pbs;
	        		var comp_menu = createPopup(), menu;
				//for( pbs = brain.first(); pbs; pbs = brain.next() )
				{
        				var idx;
					var connector;
	        			var module;
					hMenuComponents.appendItem( MF_STRING|MF_POPUP
							, comp_menu
        						, pbs.name() );
					menus.push( comp_menu );

	        			comp_menu.appendItem( MF_STRING|MF_POPUP, menu = CreatePopup(), WIDE("inputs") );
					menus.push( menu );
					

                			pbs.Inputs.list.forEach( (connector )=>
					{
        					connectors.push( connector );
						menu.appendItem(  MF_STRING, MNU_ADD_INPUT_START + (connectors.lenght-1), connector.name() );
					});
					comp_menu.appendItem( MF_STRING|MF_POPUP, menu = CreatePopup(), WIDE("outputs") );
					menus.push( menu );
					
					pbs.Outputs.list.forEach( (connector )=>
					{
        					connectors.push( connector );
						menu.appendItem(  MF_STRING, MNU_ADD_OUTPUT_START + (connectors.length-1), connector.name() );
	        			})
				}		
				comp_menu.appendItem( MF_STRING|MF_POPUP, (menu = CreatePopup() ), WIDE("module") );
				menus.push(menu);
				
				for( module = pbs.first_module(); module; idx++, module = pbs.next_module() )
				{
					BuildBrainstemMenus( menu, module, menus, connectors, idx );
					//AppendPopupItem( menu, MF_STRING, MNU_ADD_OUTPUT_START + idx + ( n * 80 ), module.name() );
					//SetLink( &outputs, idx, (POINTER)connector );
				}
				n++;
			}
		}
	}
	function Init(  )
	{
		//brainboard = this;
		//InitCommonControls();
	        
		InputPeice = NULL;
		OutputPeice = null;
		NeuronPeice = null;
		NervePeice = null;
		BackgroundPeice = null;
	        
		//PSI_CONTROL frame = CreateFrame( WIDE("Brain Editor"), 0, 0, 640, 480, BORDER_RESIZABLE, null );
		board = CreateBoardControl( null /*frame*/, 0, 0, 640, 480 );
		//DisplayFrame( frame );
		//CreateToolbin( board );
		board.SetCellSize( 16, 16 );
		if( !brain )
		{
			flags.bOwnBrain = 1;
			brain = new BRAIN();
		}
		else
			flags.bOwnBrain = 0;
		
	        
		board.SetCellSize( peices.cell.width, peices.cell.height );
	        
		board.createPeices( "background", peices.background.image
			, peices.background.cells.width, peices.background.cells.height 
			, ((peices.background.cells.width-1)/2)|0, ((peices.background.cells.height-1)/2)|0
			, background
			);

		/*
	        
		        	PARAM( args, TEXTCHAR *, type );
                		PARAM( args, uint64_t, cx );
				PARAM( args, uint64_t, cy );
                        	PARAM( args, TEXTCHAR *, filename );
				PPEICE_METHODS methods = FindPeiceMethods( type );
		        	Image image = LoadImageFile( filename );
				if( image )
				{
					console.log( WIDE("Make block %s : %s"), type, filename );
					PIPEICE pip = board.CreatePeice( type, image
													, cx, cy
													, (cx-1)/2, (cy-1)/2
													, methods 
                											, this /* brainboard
													 );
		        		console.log( WIDE("Make block %s : %s"), type, filename );
					if( methods == background_methods )
					{
                				board.SetBackground( pip );
					console.log( WIDE("Make block %s : %s"), type, filename );
                        		}
					else if( methods == neuron_methods )
		        		{
						NeuronPeice = pip;
					console.log( WIDE("Make block %s : %s"), type, filename );
                			}
					else if( methods == input_methods )
		        		{
						InputPeice = pip;
                			console.log( WIDE("Make block %s : %s"), type, filename );
					}
                        		else if( methods == output_methods )
					{
		        			OutputPeice = pip;
					console.log( WIDE("Make block %s : %s"), type, filename );
					}
                		}
				else
		        		console.log( WIDE("Failed to open %s"), filename );
			}
	        
		
				PPEICE_METHODS methods = FindPeiceMethods( type );
                		if( methods == neuron_methods )
				{
                        		neuron_methods.SetColors( (int)input_or_threshold, c1, c2, c3 );
				}
		        	else if( methods == nerve_methods )
				{
					//nerve_methods.SetColors( c1, c2, c3 );
                		}
				else if( methods == input_methods )
		        	{
					input_methods.SetColors( c1,c2,c3 );
                		}
				else if( methods == output_methods )
                        	{
					output_methods.SetColors( c1,c2,c3 );
		        	}
		*/	        
	        
		connectors = [];
		menus = [];
	        
		InitMenus();
		DefaultNeuron = brain.GetNeuron();
		DefaultSynapse = brain.GetSynapse();
	}       

//---------------------------------------------------

	function RebuildComponentPopups()
	{
		{
			var n = 0;
			var idx;
			var pbs;
			ResetPopup( hMenuComponents );
			brain.BrainStems.list.forEach( ( pbs )=>
			{
				BuildBrainstemMenus( hMenuComponents, pbs, menus, connectors, 0 );
			})
		}
	}

	function InitMenus(  )
	{
		hMenu = CreatePopup();
		hMenu.appendItem( MF_STRING, MNU_ADDNEURON, WIDE("Add &Neuron") );
           
		hMenu.appendItem( hMenu,MF_STRING|MF_POPUP, (hMenuComponents=CreatePopup()), WIDE("Add &Component") );
		{
			var n = 0;
			var idx;
			var pbs;
			brain.BrainStems.list.forEach( (pbs )=>
			{
				BuildBrainstemMenus( hMenuComponents, pbs, menus, connectors, 0 );
			} )
		}
		hMenu.appendItem( hMenu, MF_SEPARATOR,0,0 );
		hMenu.appendItem( hMenu, MF_STRING, MNU_RESET, WIDE("Reset") );
		hMenu.appendItem( hMenu, MF_STRING, MNU_RUN, WIDE("RUN") );
		hMenu.appendItem( hMenu, MF_SEPARATOR,0,0 );
		{
			var hPopup;
			hMenu.appendItem( hMenu,MF_STRING|MF_POPUP, (hPopup = CreatePopup()), WIDE("Zoom") );
			menus.push( hPopup );
        
			//hPopup = (PMENU)GetPopupData( hMenu, 6 );
			hPopup.appendItem( MF_STRING, MNU_ZOOM + 0, WIDE("x1") );
			hPopup.appendItem( MF_STRING, MNU_ZOOM + 1, WIDE("x2") );
			hPopup.appendItem( MF_STRING, MNU_ZOOM + 2, WIDE("x4") );
		}
        
		hMenu.appendItem( MF_STRING, MNU_NEURON, WIDE("Default Neuron") );
		hMenu.appendItem( MF_STRING, MNU_SYNAPSE, WIDE("Default Synapse") );
		hMenu.appendItem( MF_STRING, MNU_SIGMOID, WIDE("Sigmoid Constant") );
		hMenu.appendItem( MF_STRING, MNU_SAVE, WIDE("Save...") );
		hMenu.appendItem( MF_STRING, MNU_LOAD, WIDE("Load...") );
		hMenu.appendItem( MF_SEPARATOR,0,0 );
		hMenu.appendItem( MF_STRING, MNU_CLOSE, WIDE("Close") );
        
	}

}


/*
#ifdef BUILD_TEST_SHELL
float f_values[10];
CONNECTOR *connectors_in[] = { new connector( WIDE("one"), &f_values[0] )
,new connector( WIDE("two"), &f_values[1] )
,new connector( WIDE("three"), &f_values[2] )
,new connector( WIDE("four"), &f_values[3] )
,new connector( WIDE("five"), &f_values[4] )
,new connector( WIDE("six"), &f_values[5] )
,new connector( WIDE("seven"), &f_values[6] )
,new connector( WIDE("eight"), &f_values[7] )
,new connector( WIDE("nine"), &f_values[8] )
,new connector( WIDE("ten"), &f_values[9] )
};

CONNECTOR *connectors_out[] = { new connector( WIDE("one"), &f_values[0] )
,new connector( WIDE("two"), &f_values[1] )
,new connector( WIDE("three"), &f_values[2] )
,new connector( WIDE("four"), &f_values[3] )
,new connector( WIDE("five"), &f_values[4] )
,new connector( WIDE("six"), &f_values[5] )
,new connector( WIDE("seven"), &f_values[6] )
,new connector( WIDE("eight"), &f_values[7] )
,new connector( WIDE("nine"), &f_values[8] )
,new connector( WIDE("ten"), &f_values[9] )
};

BRAIN_STEM clusters[1] = { BRAIN_STEM( WIDE("Basic Structure")
												 , connectors_in, sizeof(connectors_in)/sizeof(connectors_in[0])
												 , connectors_out, sizeof(connectors_out)/sizeof(connectors_out[0]) ) };

// creates a thread, don't do this.
PBRAIN brains[1];// = { BRAIN( &clusters[0] ) };

SaneWinMain( argc, argv )
{

	brains[0] = new BRAIN( &clusters[0] );
	//SetAllocateLogging( true );
	new BRAINBOARD;
	new BRAINBOARD;
	new BRAINBOARD;
	while( 1 )
		Sleep( 1000 );
   return 0;
}
EndSaneWinMain()
#endif
*/



							//------------------------------------------
/*
static LOGICAL SelectNewFile( HWND hParent, PSTR szFile )
{
   
   OPENFILENAME ofn;		 // common dialog box structurechar szFile[260];		 // buffer for filenameHWND hwnd;				  // owner windowHANDLE hf;				  // file handle// Initialize OPENFILENAMEZeroMemory(&ofn, sizeof(OPENFILENAME));
   szFile[0] = 0;
   memset( &ofn, 0, sizeof( OPENFILENAME ) );
   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.hwndOwner = hParent;
   ofn.lpstrFile = szFile;
   ofn.nMaxFile = 256;
   ofn.lpstrFilter = WIDE("Bodies\0*.Body\0");
   ofn.nFilterIndex = 1;
   ofn.Flags = OFN_NOTESTFILECREATE
				  | OFN_NOREADONLYRETURN ;// Display the Open dialog box. 

   return GetOpenFileName(&ofn);
}
*/


/*
class IVIA: public IPEICE
{
public:
	//virtual ~IVIA();
	virtual CTEXTSTR name( void )=0;
	virtual Image GetViaStart( int direction, int scale = 0 )=0;// { return null; }
	virtual Image GetViaEnd( int direction, int scale = 0 )=0;//{ return null; }
	// getviafromto will result in start or end if from or to is NOWHERE respectively
	virtual Image GetViaFromTo( int from, int to, int scale = 0 ){ return null; }

	virtual Image GetViaFill1( int *xofs, int *yofs, int direction, int scale = 0 ){ return null; }
	virtual Image GetViaFill2( int *xofs, int *yofs, int direction, int scale = 0 ){ return null; }
	virtual int Move( void ) { return 0; } // Begin, Start
	virtual int Stop( void ) { return 0; } // end
	PVIA_METHODS via_methods;
};
*/


function NERVE_METHODS(newbrainboard) {
	if( !(this instanceof NERVE_METHODS) ) return new MERVE_METHODS(newbrainboard);

	//this.methods = 
	this.brainboard = newbrainboard;
	this.synapse = null
};

NERVE_METHODS.prototype = new DefaultViaMethods();
NERVE_METHODS.prototype.constructor = NERVE_METHODS;

NERVE_METHODS.prototype.Create = function( psvExtra )
{
	return this.brainboard.brain.DupSynapse( brainboard.DefaultSynapse );
}
NERVE_METHODS.prototype.Destroy = function(  psv )
{
	this.brainboard.brain.ReleaseSynapse( psv );
}
NERVE_METHODS.prototype.Disconnect = function(  psv )
{
	this.brainboard.brain.UnLinkSynapseTo( psv );
	return true;
}
NERVE_METHODS.prototype.OnRightClick = function(  psv,  x,  y )
{
	console.log( "Show Synapse in Statuses" );
	//ShowSynapseDialog( (PSYNAPSE)psv );
	return 1;
}


function  INPUT_METHODS(newbrainboard)
{
	if( !(this instanceof INPUT_METHODS) ) return new INPUT_METHODS(newbrainboard);
	this.brainboard = newbrainboard;
	this.level_colors = [];
}

INPUT_METHODS.prototype = new DefaultMethods();
INPUT_METHODS.prototype.constructor = INPUT_METHODS;

INPUT_METHODS.prototype.Create = function(  psvExtra )
	{
		//brainboard.create_input_type = (POUTPUT_INPUT)psvExtra;
		//brainboard.create_input_type.flags.bOutput = 0;
		console.log( WIDE("Creating a new input (peice instance)") );
		//this.brainboard.brain.GetInputNeuron( ((POUTPUT_INPUT)psvExtra).pbs, ((POUTPUT_INPUT)psvExtra).conn
		return psvExtra; // still not the real create...  but this is psviNstance...
	}
INPUT_METHODS.prototype.SetColors = function(  c1,  c2,  c3 )
	{
		this.level_colors[0] = c1;
		this.level_colors[1] = c2;
		this.level_colors[2] = c3;
	}
INPUT_METHODS.prototype.Draw = function(  psvInstance,  image,  cell,  x,  y )
	{
		var cPrimary;
		var input = psvInstance;
		var value = input.conn.get();
		console.log( ("input value is %g"), value );
		if( value < 0 )
			cPrimary = ColorAverage( level_colors[1]
										  , level_colors[0]
											, -(value * 1200)|0, 1000 );
		else
			cPrimary = ColorAverage( level_colors[1]
											, level_colors[2]
									  , (value*1200)|0, 1000 );

		BlotImageShaded( image
		               , cell //master.getcell(cellx, celly)
		               , x, y
		               , cPrimary );
	}
INPUT_METHODS.prototype.ConnectEnd = function(  psv_to_instance,  x,  y
									  ,  peice_from,  psv_from_instance )
	{
		return false;
	}
INPUT_METHODS.prototype.ConnectBegin = function(  psv_to_instance,  x,  y
									  ,  peice_from,  psv_from_instance )
	{
		var n;
		//if( peice_from == brainboard.NerveMethods )
		// maybe...
		var synapse = psv_from_instance;
		var neuron = psv_to_instance;
		// validate that peice_from is a nerve_method type
		for( n = 0; n < 8; n++ )
			if( DirDeltaMap[n].x == x && DirDeltaMap[n].y == y )
				break;
		if( n < 8 )
			return brainboard.brain.LinkSynapseFrom( synapse, neuron.neuron, n );
		return false;
	}
INPUT_METHODS.prototype.OnRightClick = function(  psv,  x,  y )
	{
      //ShowInputDialog( (PNEURON)psv );
      return 1;
	}

INPUT_METHODS.prototype.OnClick = function(  psv,  x, y )
{
	console.log( WIDE("click on input! at %d,%d"), x, y );
	if( x == 0 && y == 0 )
	{
		// this is implied to be the current peice that
		// has been clicked on...
		// will receive further OnMove events...
		brainboard.board.LockPeiceDrag();
		return true;
	}
	else
	{
		if( !brainboard.board.BeginPath( brainboard.NervePeice, brainboard ) )
		{
			// attempt to grab existing path...
			// current position, and current layer
			// will already be known by the grab path method
			//brainboard.board.GrabPath();
		}
	}
	// so far there's nothing on this cell to do....
	return false;
}



function  OUTPUT_METHODS( newbrainboard )
{
	if( !(this instanceof OUTPUT_METHODS) ) return new OUTPUT_METHODS(newbrainboard);
	this.brainboard = newbrainboard; 

	this.level_colors = [ ];
}

OUTPUT_METHODS.prototype = new DefaultMethods();
OUTPUT_METHODS.prototype.constructor = OUTPUT_METHODS;

OUTPUT_METHODS.prototype.Create = function(  psvExtra )
	{
		//brainboard.create_output_type = (POUTPUT_INPUT)psv;
		//brainboard.create_output_type.flags.bOutput = 1;
        console.log( "Creating a new output (peice instance)" );

		var poi = psvExtra;

		poi.neuron = brainboard.brain.GetOutputNeuron( poi.conn );
		//DupNeuron( brainboard.DefaultNeuron ))

		return psvExtra; // still not the real create...  but this is psviNstance...
		//return poi.neuron; // still not the real create...  but this is psviNstance...
		//return (((POUTPUT_INPUT)psvExtra).conn); // still not the real create...  but this is psviNstance...
		//return (brainboard.create_output_type);
	}
OUTPUT_METHODS.prototype.Draw = function(  psvInstance,  image,  cell,  x,  y )
	{
		var cPrimary;
		var neuron = psvInstance;
		var poi = psvInstance;
		//PANYVALUE output = neuron.Output; //(connector*)psvInstance;
		var value = neuron.get(); //output.get();
		if( value < 0 )
			cPrimary = ColorAverage( this.level_colors[1]
										  , this.level_colors[0]
											, (int)-(value * 1200), 1000 );
		else
			cPrimary = ColorAverage( this.level_colors[1]
											, this.level_colors[2]
									  , (int)(value*1200), 1000 );

		BlotImageShaded( image
								  , cell //master.getcell(cellx, celly)
								  , x, y
								  , cPrimary );
	}

OUTPUT_METHODS.prototype.SetColors = function(  c1,  c2,  c3 )
	{
		this.level_colors[0] = c1;
		this.level_colors[1] = c2;
		this.level_colors[2] = c3;
	}
OUTPUT_METHODS.prototype.ConnectEnd = function(  psv_to_instance,  x,  y
									  ,  peice_from,  psv_from_instance )
	{
		var n;
		var success = false;
		//POUTPUT_INPUT poi = (POUTPUT_INPUT)psv_to_instance;
		//POUTPUT_INPUT poi = (POUTPUT_INPUT);
		//connector *output = (connector*)psv_to_instance;
		//if( peice_from == brainboard.NerveMethods )
		// maybe...
		var synapse = psv_from_instance;
		var neuron = psv_to_instance;
		// validate that peice_from is a nerve_method type
		//poi.
		for( n = 0; n < 8; n++ )
			if( DirDeltaMap[n].x == x && DirDeltaMap[n].y == y )
				break;
		if( n < 8 )
		{
			var success = brainboard.brain.LinkSynapseTo( synapse, neuron.neuron, n );
			return success;
		}
		return false;
	}
OUTPUT_METHODS.prototype.ConnectBegin = function(  psv_to_instance,  x,  y
									  ,  peice_from,  psv_from_instance )
	{
		return false;
	}
OUTPUT_METHODS.prototype.OnRightClick = function(  psv,  x,  y )
	{
		//ShowOutputDialog( (PNEURON)psv );
		return 1;
	}
OUTPUT_METHODS.prototype.OnClick = function(  psv,  x,  y )
	{
		console.log( "click on neuron! at %d,%d", x, y );
		if( x == 0 && y == 0 )
		{
			// this is implied to be the current peice that
			// has been clicked on...
			// will receive further OnMove events...
			brainboard.board.LockPeiceDrag();
			return true;
		}
		else
		{
			if( !brainboard.board.BeginPath( brainboard.NervePeice, brainboard ) )
			{
				// attempt to grab existing path...
				// current position, and current layer
				// will already be known by the grab path method
				//brainboard.board.GrabPath();
			}
		}
		// so far there's nothing on this cell to do....
		return false;
	}




function  NEURON_METHODS(newbrainboard)
{
	// these methods are passed a psvInstance
	// which is the current neuron instance these are to wokr on
	// this valud is retrieved and stored (by other portions) by the create() method
	this.brainboard = newbrainboard;

	this.c_input = []; // 0=min,1=mid,2=max
	this.c_threshold = []; // 0=min,1=mid,2=max
	this.connected = [];

}

NEURON_METHODS.prototype = new DefaultMethods();
NEURON_METHODS.prototype.constructor = NEURON_METHODS;

NEURON_METHODS.prototype.SetColors = function( bInput,  c1,  c2,  c3 )
	{
		if( bInput )
		{
			this.c_input[0] = c1;
			this.c_input[1] = c2;
			this.c_input[2] = c3;
		}
		else
		{
			this.c_threshold[0] = c1;
			this.c_threshold[1] = c2;
			this.c_threshold[2] = c3;
		}
	}
NEURON_METHODS.prototype.Create = function(  psvExtra )
	{
		console.log( "Creating a new neuron (peice instance)");
		return brainboard.brain.DupNeuron( brainboard.DefaultNeuron );
	}
NEURON_METHODS.prototype.Destroy = function(  psv )
	{
      brainboard.brain.ReleaseNeuron( psv );
	}
	
NEURON_METHODS.prototype.Draw = function(  psvInstance,  image,  cell,  x,  y )
	{
      //console.log( WIDE("---------- DRAW NEURON ------------") );

		var cPrimary, cSecondary, cTertiary;
	      //var base,range,value,input,threshold;
		var neuron = psvInstance;

		var vals = neuron.get();

		//     |(base)   -. range
		//        0 // 0 origin may not be the center of a neuron...
		// operational parameters of neurons may be done in such a way
      // that they are centered around some arbitrary number other than 0

		// base -100 range 500
		// center is 200
		// threshold of 100 is
      //    100-(-100) (200/range)

		var threshold = (2*(vals.threshold - vals.base)) / vals.range;
		threshold -= 1.0;
		// threshold is now -1.0 to 1.0 biased.

		var value = ( 2 * ( vals.value - vals.base ) ) / vals.range;
		value -= 1.0;
		// value is now -1.0 to 1.0 biased.

		if( value > 1.0 )
			value = 1.0;
		else if( value < -1.0 )
			value = -1.0;

		if( input < 0 )
			cPrimary = ColorAverage( c_input[1]
										  , c_input[0]
											, -(value * 1000)|0, 1000 );
		else
			cPrimary = ColorAverage( c_input[1]
											, c_input[2]
									  , (value*1000)|0, 1000 );

		if( threshold )
			cSecondary = ColorAverage( c_threshold[1],
									  c_threshold[0],
										 -(threshold*1000)|0, 1000 );
		else
			cSecondary = ColorAverage( c_threshold[1],
										 c_threshold[2],
										 (threshold*1000)|0, 1000 );
		cTertiary = 0; // no other value...

		BlotImageMultiShaded( image
				, cell //master.getcell(cellx, celly)
				, x, y
				, cTertiary, cSecondary, cPrimary );
	}

NEURON_METHODS.prototype.Update = function(  psv,  cycle )
	{
		console.log( "updating color information for a neuron..." );
	}

NEURON_METHODS.prototype.ConnectEnd = function(  psv_to_instance,  x,  y
									  ,  peice_from,  psv_from_instance )
	{
		var n;
		//if( peice_from == brainboard.NerveMethods )
		// maybe...
		var synapse = psv_from_instance;
		var neuron = psv_to_instance;
		// validate that peice_from is a nerve_method type
		for( n = 0; n < 8; n++ )
			if( DirDeltaMap[n].x == x && DirDeltaMap[n].y == y )
				break;
		if( n < 8 )
		{
			var success = brainboard.brain.LinkSynapseTo( synapse, neuron, n );
			return success;
		}
		return false;
	}

NEURON_METHODS.prototype.ConnectBegin = function(  psv_to_instance,  x,  y
									  ,  peice_from,  psv_from_instance )
	{
		var n;
		//if( peice_from == brainboard.NerveMethods )
		// maybe...
		var synapse = psv_from_instance;
		var neuron = psv_to_instance;
		// validate that peice_from is a nerve_method type
		for( n = 0; n < 8; n++ )
			if( DirDeltaMap[n].x == x && DirDeltaMap[n].y == y )
				break;
		if( n < 8 )
			return brainboard.brain.LinkSynapseFrom( synapse, neuron, n );
		return false;
	}
NEURON_METHODS.prototype.OnRightClick = function(  psv,  x,  y )
	{
		ShowNeuronDialog( psv );
		return 1;
	}

NEURON_METHODS.prototype.OnClick = function(  psv,  x,  y )
	{
		console.log( WIDE("click on neuron! at %d,%d"), x, y );
		if( x == 0 && y == 0 )
		{
			// this is implied to be the current peice that
			// has been clicked on...
			// will receive further OnMove events...
			brainboard.board.LockPeiceDrag();
			return true;
		}
		else
		{
			if( !brainboard.board.BeginPath( brainboard.NervePeice, brainboard ) )
			{
				// attempt to grab existing path...
				// current position, and current layer
				// will already be known by the grab path method
				//brainboard.board.GrabPath();
			}
		}
		// so far there's nothing on this cell to do....
		return false;
	}


function BackgroundMethods( _brainboard ) {
	if( !(this instanceof BackgroundMethods ) ) return new BackgroundMethods( _brainboard );

	this.brainboard = _brainboard;

	//typedef PEICE_METHODS Parent;

}

BackgroundMethods.prototype = new DefaultMethods();
BackgroundMethods.prototype.constructor = BackgroundMethods;


BackgroundMethods.prototype.Create = function() {
			return true;
		}
BackgroundMethods.prototype.Destroy = function() {
		
	}

BackgroundMethods.prototype.Connect  = function (  psvTo
				  , rowto,  colto
				  ,  psvFrom
				  ,  rowfrom,  colfrom )
	{
		return 0;
	}

BackgroundMethods.prototype.Update = function(  psv,  cycle )
	{
	      console.log( WIDE("Update background - nothing to do.") );
		//parent.Update(psv,cycle);
	}

BackgroundMethods.prototype.OnClick = function(  psv,  x,  y )
	{
		brainboard.board.LockDrag();
		return true;
	}

BackgroundMethods.prototype.OnRightClick = function(  psv,  x,  y )
	{
		brainboard.RebuildComponentPopups();

		var result = TrackPopup( brainboard.hMenu, null );
		//DebugBreak();
		if( result >= MNU_ADD_INPUT_START && result < MNU_ADD_OUTPUT_START )
		{
			console.log( WIDE("Put input peice at %d,%d"), x, y );
			var io_thing = new OUPUT_INPUT( brainboard );
			//io_thing.brainboard = brainboard;
			//io_thing.brain = io_thing.brainboard.brain;
			io_thing.conn = brainboard.connectors[ result-MNU_ADD_INPUT_START ];// io_thing.pbs.getinput( (result-MNU_ADD_INPUT_START) %80 );

			io_thing.neuron = io_thing.brain.GetInputNeuron( io_thing.conn );
			//brainboard.create_input_type = GetLink( &brainboard.inputs, result-MNU_ADD_INPUT_START );

			// really this only needs to pass the connector? or do I need to get a Input/Ouptut Neuron?
			brainboard.board.PutPeice( brainboard.InputPeice, x, y, io_thing );
		}
		else if( result >= MNU_ADD_OUTPUT_START && result <= MNU_ADD_OUTPUT_LAST )
		{
			console.log( WIDE("Put output peice at %d,%d"), x, y );
			var io_thing = new OUPUT_INPUT( brainboard );
			//io_thing.brainboard = brainboard;
			//io_thing.brain = io_thing.brainboard.brain;
			io_thing.conn = brainboard.connectors[ result-MNU_ADD_OUTPUT_START ];// io_thing.pbs.getoutput( (result-MNU_ADD_OUTPUT_START)%80 );

			// really this only needs to pass the connector? or do I need to get a Input/Ouptut Neuron?
			brainboard.board.PutPeice( brainboard.OutputPeice, x, y, io_thing );
		}
		else switch( result )
		{
		case MNU_ADDNEURON:
			console.log( WIDE("Put neuron peice at %d,%d"), x, y );
			brainboard.board.PutPeice( brainboard.NeuronPeice, x, y, 0 );
			return true;
		case MNU_ZOOM:
		case MNU_ZOOM+1:
		case MNU_ZOOM+2:
		   brainboard.board.SetScale( result - MNU_ZOOM );
		   break;
	  	case MNU_SAVE:
		   {
						var name = PickBoardName( null, false );
						if( name )
							brainboard.board.Save( null, name );
		   }

			break;
		case MNU_LOAD:
			{
				var name = PickBoardName( null, true );
				if( name )
					brainboard.board.Load( null, name );
			}
			break;
		case MNU_CLOSE:
			//delete brainboard;
			return false;
		}
		return true;
	},
BackgroundMethods.prototype.OnDoubleClick = function(  psv,  x,  y )
	{
		 result = TrackPopup( brainboard.hMenu, null );
		return true;
	}


//--------------------------- Quick Popup Menu System ------------------------------

var mouseCatcher = document.getElementById( "mouseCatcher" );
var topMenu;
mouseCatcher.addEventListener( "click", (evt)=>{
	if( topMenu )
		topMenu.hide( true );
} );
	

function createPopup() {
	var menu = {
		items: [],
		parent : null,
		container : document.createElement( "div" ),
		// hMenu, MF_STRING, MNU_ADDNEURON, WIDE("Add &Neuron") );
		appendItem( _flags, value, text ) {
			var newItem = document.createElement( "A" );
			this.container.appendChild( newItem );
			var flags = _flags;
			newItem.value = value;
			newItem.textContent = text;
			newItem.className = "popup";
			if( flags & MF_POPUP ) {
				value.parent = this;
				newItem.addEventListener( "click", (evt)=>{
					console.log( "Item is clicked.", evt.target.value );
					newItem.value.show( evt.clientX, evt.clientY );
					
				} );
			} else
				newItem.addEventListener( "click", (evt)=>{
					console.log( "Item is clicked.", evt.target.value );
					this.hide( true );
				} );
		},
		hide( all ) {
			this.container.style.visiblity = "hidden";
			if( this.parent ) {
				if( all )
					this.parent.hide( all );
			} else {
				mouseCatcher.style.visibility = "hide"
			}
		},
		show( x, y ) {
			this.container.style.visilbity = "visibile";
			this.container.style.left = x;
			this.container.style.top = y;
		}
		
	};
	
	menu.container.className = "popup";
	menu.container.style.zIndex = 50;

	return menu;
}

