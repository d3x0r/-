
export default { defaultExport:"NoMethods"}

export const direction = {
	 NOWHERE : -1,
	 UP :0,
	 UP_RIGHT :1,
	 RIGHT :2,
	 DOWN_RIGHT: 3,
	 DOWN :4,
	 DOWN_LEFT :5,
	 LEFT :6,
	 UP_LEFT :7,
}

Object.freeze( direction );


export const DirDeltaMap = [ { x: 0, y:-1 },
                     { x:1, y:-1 }, 
		     { x:1, y:0 }, 
		     { x:1, y:1 }, 
		     { x:0, y:1 } , 
		     { x:-1, y:1 },  
		     { x:-1, y:0 },
		     { x:-1, y:-1 } 
		];
Object.freeze( DirDeltaMap );
DirDeltaMap.forEach( (del)=>Object.freeze(del) );



function Cell(p,c,r) {
	// peice - full peice definition, has
	// one method - getcell.
	// the col, row expressed here is the specific
	// portion of the peice.
	return {
		peice:p,
		col:c,
		row:r,		
	}
}



export function createPeice(  board,  name //= "A Peice"
							 ,  image //= null
							 ,  rows //= 1
							 ,  cols //= 1
							 ,  hotspot_x
							 ,  hotspot_y
							 ,  methods //= null
							 ,  psv
							 ) 
{
	var peice = new Peice( board, name, image, rows, cols, hotspot_x, hotspot_y, TRUE, FALSE, methods, psv );
	if( methods )
		methods.SetPeice( peice );
	return peice; // should be able to auto cast this...
}


//--------------------------- Default Methods ------------------------------------------

function DefaultMethods() {
	if( !(this instanceof DefaultMethods ) ) return new DefaultMethods();
	this.master = this;
}

DefaultMethods.prototype.Move = function() {
	return false;
}

DefaultMethods.prototype.Stop = function() {
	return false;
}


DefaultMethods.prototype.name  = function() { return "default methods"; }
DefaultMethods.prototype.SetPeice = function(  peice )        { this.master = peice; }
DefaultMethods.prototype.getimage = function()                { return this.master.getimage(); };
DefaultMethods.prototype.getcell = function(  x,  y )         { return this.master.getcell(x,y); };
DefaultMethods.prototype.getimage = function( scale)          { return this.master.getimage(scale); };
DefaultMethods.prototype.getcell = function(  x,  y,  scale ) { return this.master.getcell(x,y,scale); };
DefaultMethods.prototype.gethotspot = function(  )            { return this.master.gethotspot(); };
DefaultMethods.prototype.getsize = function(  )               { return this.master.getsize(); };

//class DEFAULT_METHODS:public PEICE_METHODS {
DefaultMethods.prototype.Create = function( psvExtra )
	{
		return 0;
	}
DefaultMethods.prototype.Disconnect = function(  psv1 /*, PIPEICE peice, uintptr_t psv2*/ )
	{
      return 0;
	}
DefaultMethods.prototype.Destroy = function( psv )
	{
	}

DefaultMethods.prototype.Update = function(  psv,  cycle )
	{
		return; // do nothing to update...
		// consider on failure
		// Destroy( psv );
	}
DefaultMethods.prototype.OnMove = function(  psv )
	{
	}
DefaultMethods.prototype.ConnectBegin  = function(  psv_to_instance,  x,  y
											  , peice_from,  psv_from_instance )
	{
      return false;
	}
DefaultMethods.prototype.ConnectEnd  = function(  psv_to_instance,  x,  y
											  ,  peice_from,  psv_from_instance )
	{
      return false;
	}
DefaultMethods.prototype.OnClick = function(  psv,  x,  y )
	{
		return false;
	}
DefaultMethods.prototype.OnRightClick = function(  psv,  x,  y )
	{
		return false;
	}
DefaultMethods.prototype.OnDoubleClick = function(  psv,  x,  y )
	{
		return false;
	}
   /*
	void PEICE_METHODS::Draw( uintptr_t psvInstance, Image surface, int x, int y, int cellx, int celly )
	{
		// first 0 is current scale.
		lprintf( WIDE("Drawing peice instance %p cell: %d,%d at: %d,%d"), psvInstance, cellx, celly, x, y );
		//lprintf( WIDE("Drawing %d by %d"), rows, cols );
		BlotImage( surface
					, master.getcell(cellx, celly)
					, x, y
					);
	}
   */
DefaultMethods.prototype.Draw = function(  psvInstance,  surface,  peice,  x,  y )
{
	// first 0 is current scale.
	//lprintf( WIDE("Drawing peice instance %p"), psvInstance );
	//lprintf( WIDE("Drawing %d by %d"), rows, cols );

	BlotImageAlpha( surface
					  , peice
					  , x, y
					  , 1 );
}

//-------------------- DEFAULT VIA METHODS (a few more than PEICE_METHODS ) ----------------------------

export function DefaultViaMethods() {
	if( !(this instanceof DefaultViaMethods ) ) return new DefaultViaMethods();
	
}

DefaultViaMethods.prototype = new DefaultMethods();
DefaultViaMethods.prototype.constructor = DefaultViaMethods();


DefaultViaMethods.prototype.Move = function( )
{
      return 0;
}
DefaultViaMethods.prototype. Stop = function( )
{
      return 0;
}

//-------------------- VIA METHODS ----------------------------------


function ViaMethods() {
	if( !(this instanceof DefaultViaMethods ) ) return new DefaultViaMethods();
	
}

ViaMethods.prototype = new DefaultViaMethods();
ViaMethods.prototype.constructor = ViaMethods();

ViaMethods.prototype.OnClick = function(  psv,  x,  y )
{
	//	lprintf(WIDE(" Psh we have to find segment at %d,%d again... actually we only care if it's the last..."), x, y );
	//	PLAYER_NODE_DATA pld = (PLAYER_NODE_DATA)PeekStack( &pds_path );
	//	if( pld.x == x && pld.y == y )
	{
		// mouse current layer...
		console.log( "GENERATE DISCONNECT!" );
		master.board.UnendPath( );
		//Disconnect();
	}
	return 0;
}
ViaMethods.prototype.OnRightClick = function(  psv,  x,  y )
{
	return 0;
}
ViaMethods.prototype.OnDoubleClick = function(  psv,  x,  y )
{
	return 0;
}


//class PEICE:public IPEICE, private PEICE_DATA
export function Peice( board
		  ,  name
		  ,  image //= null
		  ,  rows// = 1
		  ,  cols// = 1
		  ,  hotx //= 0//(cols-1)/2
		  ,  hoty //= 0//(rows-1)/2
        ,  bBlock// = 0
		  ,  bVia //= 0
        ,  methods //= null
		,  psv //= 0
		)
{


	//if( !(this instanceof PeiceData ) ) return new PeiceData( _name,_image,_rows,_cols,_hotx,_hoty,_bBlock,_bVia)

	this.flags =  {
		 block:0,
		 viaset:0,
	};
	this.original;
	this.scaled= [];// x1, x2, x4 // [3] ( [rows][cols] ) + 1
	this.current_scale; // set by setting scale...

	this.cellSize = board.GetCellSize( );
	this.rows = _rows;
	this.cols = _cols;
	this.hotx = _hotx;
	this.hoty = _hoty;
	this.board = _board;
	//PEICE_DATA::image = image;
	this.name = _name;
	this.original = image;

	// this should be moved out to a thing which is
	// like re-mip-map :)
	// or recompute based on a new cell size of the main board...
	if( image )
	{
		var scale = 0, x, y;
		if( scaled )
			Release( scaled );

/*
		scaled = (Image*)Allocate( sizeof( Image ) * (1 + rows * cols)* 3 );
		lprintf( WIDE("Begin scaling..") );
		scaled[0] = MakeImageFile( cell_width * cols, cell_height * rows );
		lprintf( WIDE("scale %d scaling.. to %d %d"), scale, cell_width * cols, cell_height * rows );
		BlotScaledImage( scaled[0], original );
		lprintf( WIDE("Begin scaling..") );
*/
		for( scale = 0; scale < 3; scale++ )
		{
			if( scale )
			{
				// scale==0 already done.
				scaled[ scale * ( (rows*cols) + 1 ) ] = MakeImageFile( (cell_width * cols)/(1<<scale)
																					  , (cell_height * rows)/(1<<scale) );
				// blot original image for least loss of detail..
				BlotScaledImage( scaled[scale * ( (rows*cols) + 1 ) ]
									, original );
			}
			lprintf( WIDE("scale %d scaling.."), scale );
			// if anything - because of blocking and clipping
			// then ANY thing may need to be cut into cells

			//if( bVia ) // blocks don't neeeed to be cut ...
			{
				var image = scaled[scale * ((rows*cols)+1)];
				for( x = 0; x < cols; x++ )
					for( y = 0; y < rows; y++ )
					{
						var tmp;
						tmp =
							scaled[ scale * ( (rows*cols) + 1 ) + ( x + (y*cols) ) + 1 ] =
							MakeSubImage( image
											, ( x * image.width ) / cols
											, ( y * image.height ) / rows
											, ( ((x+1) * image.width ) / cols) - (( x * image.width ) / cols)
											, ( ((y+1) * image.height ) / rows) - (( y * image.height ) / rows)
											);
					}
			}
		}
		// level 0 scaled
		current_scale = scaled;
	}
	else
		scaled = null;


	// private method therefore safe.
	//Image GetCell( void )
	//{
   	//   return scaled[0 * ((rows*cols)+1)];
	//}

	//--------------------------------------------------------------

	//inline Image getcell( int32_t x, int32_t y )
	//{
	//	if( x >=0 && x < cols && y >= 0 && y < rows )
	//      // 0 == scale ...
	//		return scaled[0 * ( (rows*cols) + 1 ) + ( x + (y*cols) ) + 1 ];
	//   return null;
	//}

	//--------------------------------------------------------------
	//--------------------------------------------------------------
        
        
	//super(board, name,image,rows,cols,hotx,hoty,bBlock,bVia)

	{

		// from the original file deifnitino psv here is totally bogus.
		this.psvCreate = psv; /* brainboard for now?*/
		if( !methods )
			this.methods = DefaultMethods;
		else
			this.methods = methods;
	};
}

Peice.prototype.name = function()
	{
		return this.name;
	}
Peice.prototype.Destroy = function()
	{
		//delete this;   
	}
Peice.prototype.getimage = function(  )
{
	  return this.current_scale[0];
}

Peice.prototype.getimage = function( scale )
{
   if( scale < 3 && scale >= 0 )
		return scaled[( (rows*cols) + 1 )*scale];
   return null;
}

Peice.prototype.getcell = function( x, y )
{
	if( x < 0 ) x += cols;
	if( y < 0 ) y += rows;
	if( x > cols ) x %= cols;
	if( y < rows ) y %= rows;
	return current_scale[( x + (y*cols) ) + 1 ];
}


Peice.prototype.getcell = function(  x, y,  scale )
{
	if( x < 0 ) x += cols;
	if( y < 0 ) y += rows;
	if( x > cols ) x %= cols;
	if( y < rows ) y %= rows;
	{
		if( scale < 3 && scale >= 0 )
			return scaled[( (rows*cols) + 1 )*scale + ( x + (y*cols) ) + 1 ];
	}
   return null;
}


Peice.prototype.getsize = function(  )
{
	return { rows: this.rows, cols: this.cols };
}
Peice.prototype.gethotspot = function(  )
{
	return this.hot;
}



//typedef class VIA *PVIA;
//class VIA:public IVIA, public VIA_DATA
export function Via(board
		, name
		, image //= null
		, methods //= null
		, psv //= 0
	) 
{
	//--------------------------------------------------------------

	function GetViaEnd( direction, scale )
	{
      // to direction...
		switch( direction )
		{
		case UP_LEFT:
			return getcell( 2, 2, scale );
		case UP:
			return getcell( 3, 2, scale );
		case UP_RIGHT:
			return getcell( 4, 2, scale );
		case RIGHT:
			return getcell( 4, 3, scale );
		case DOWN_RIGHT:
			return getcell( 4, 4, scale );
		case DOWN:
			return getcell( 3, 4, scale );
		case DOWN_LEFT:
			return getcell( 2, 4, scale );
		case LEFT:
			return getcell( 2, 3, scale );
		case NOWHERE:
			return getcell( 3, 3, scale );
		}
		return null;
	}

	//--------------------------------------------------------------

	function GetViaFill1( xofs, yofs, direction, scale )
	{
        	var outofs = { x : 0, y : 0, cell:null };
		switch( direction )
		{
		case UP_LEFT:
			outofs.x = 0;
			outofs.y = -1;
                        outofs.cell = getcell( 5, 0, scale );
			return outofs;
		case DOWN_RIGHT:
			outofs.x = 1;
			outofs.y = 0;
                        outofs.cell = getcell( 5, 0, scale );
			return outofs 
                        break;
		case UP_RIGHT:
			outofs.x = 0;
			outofs.y = -1;
                        outofs.cell = getcell( 1, 0, scale );
			return outofs;
		case DOWN_LEFT:
			outofs.x = -1;
			outofs.y = 0;
                        outofs.cell =  getcell( 1, 0, scale );
			return outofs;
		}
       		return outofs 
	}
	// the diagonal fills are ... well position needs to
	   // be accounted for ...

	//--------------------------------------------------------------

	function GetViaFill2( xofs, yofs, direction, scale )
	{
        	var outofs = { x : 0, y : 0, cell:null };
		// via vills are done when placing a cell that exits in 'direction'
		// the xofs should be applied to the x,y of the last cell - the one that
		// is exiting in 'direction'
		// layers will consider fills as temporary and auto trash them when unwinding.
		// Any cell may call GetViaFill, GetViaFill2 in exit direction,
		// a direction which does not require a fill will result in null
		// otherwise the information from this should be saved, and somewhat attached
      // to the peice just layed.
		switch( direction )
		{
		case UP_LEFT:
			outofs.x = -1;
			outofs.y = 0;
                        outofs.cell = getcell( 4, 1, scale );
			return outofs;
		case DOWN_RIGHT:
				outofs.x = 0;
				outofs.y = 1;
                        outofs.cell = getcell( 4, 1, scale );
			return outofs;
		case UP_RIGHT:
			outofs.x = 1;
			outofs.y = 0;
                        outofs.cell = getcell( 2, 1, scale );
			return outofs;
		case DOWN_LEFT:
				outofs.x = 0;
				outofs.y = 1;
                        outofs.cell = getcell( 2, 1, scale );
			return outofs;
		}
		return null;
	}

	//--------------------------------------------------------------

	function GetViaStart(  direction,  scale )
	{
      // from direction...
		switch( direction )
		{
		case UP_LEFT:
			return getcell( 6, 6, scale );
		case UP:
			return getcell( 3, 5, scale );
		case UP_RIGHT:
			return getcell( 0, 6, scale );
		case RIGHT:
			return getcell( 1, 3, scale );
		case DOWN_RIGHT:
			return getcell( 0, 0, scale );
		case DOWN:
			return getcell( 3, 1, scale );
		case DOWN_LEFT:
			return getcell( 6, 0, scale );
		case LEFT:
			return getcell( 5, 3, scale );
		case NOWHERE:
			return getcell( 3, 3, scale );
		}
		return null;
	};
	//--------------------------------------------------------------

	function GetViaFromTo( from, to,  scale )
	{
		if( from == NOWHERE )
		{
			return GetViaStart( to, scale );
		}
		else if( to == NOWHERE )
		{
			return GetViaEnd( from, scale );
		}
		switch( from | ( to << 4 ) )
		{
		case LEFT|(UP_RIGHT<<4):
		case UP_RIGHT|(LEFT<<4):
			return getcell( 4, 6, scale );
		case LEFT|(RIGHT<<4):
		case RIGHT|(LEFT<<4):
			return getcell( 3, 0, scale );
		case UP_LEFT|(RIGHT<<4):
		case RIGHT|(UP_LEFT<<4):
			return getcell( 2, 6, scale );
		case LEFT|(DOWN_RIGHT<<4):
		case DOWN_RIGHT|(LEFT<<4):
			return getcell( 4, 0, scale );
		case UP_LEFT|(DOWN_RIGHT<<4):
		case DOWN_RIGHT|(UP_LEFT<<4):
			return getcell( 5, 1, scale );
		case UP|(DOWN_RIGHT<<4):
		case DOWN_RIGHT|(UP<<4):
			return getcell( 0, 4, scale );
		case UP_LEFT|(DOWN<<4):
		case DOWN|(UP_LEFT<<4):
			return getcell( 6, 2, scale );
		case UP|(DOWN<<4):
		case DOWN|(UP<<4):
			return getcell( 0, 3, scale );
		case UP_RIGHT|(DOWN<<4):
		case DOWN|(UP_RIGHT<<4):
			return getcell( 0, 2, scale );
		case UP|(DOWN_LEFT<<4):
		case DOWN_LEFT|(UP<<4):
			return getcell( 6, 4, scale );
		case UP_RIGHT|(DOWN_LEFT<<4):
		case DOWN_LEFT|(UP_RIGHT<<4):
			return getcell( 1, 1, scale );
		case RIGHT|(DOWN_LEFT<<4):
		case DOWN_LEFT|(RIGHT<<4):
			return getcell( 2, 0, scale );
		}
      return null;
	}


	function name()
	{
		return this.name;
	}


	// plus additional private methods relating to vias....
	function Move(  ) { return 0; }
	function Stop(  ) { return 0; }

	function getimage( )
	{
		return current_scale[0];
	}

	function getimage( scale )
	{
		if( scale < 3 && scale >= 0 )
			return scaled[( (rows*cols) + 1 )*scale];
		return null;
	}

	function getcell( x, y )
	{
		if( x < 0 ) x += cols;
		if( y < 0 ) y += rows;
		if( x > cols ) x %= cols;
		if( y < rows ) y %= rows;
		return current_scale[( x + (y*cols) ) + 1 ];
	}


	function getcell( x, y, scale )
	{
		if( x < 0 ) x += cols;
		if( y < 0 ) y += rows;
		if( x > cols ) x %= cols;
		if( y < rows ) y %= rows;
		if( scale < 3 && scale >= 0 )
			return scaled[( (rows*cols) + 1 )*scale + ( x + (y*cols) ) + 1 ];
		return null;
	}
	function  getsize( )
	{
		return { rows: rows, cols: cols };
	}
	function gethotspot( )
	{
		return { x:hotx, y:hoty };
	}

};


function ViaData(  board,  name
			  ,  image 
			  )
{
	//super(board, name,image,7,7,0,0,FALSE,TRUE)	
}

ViaData.prototype = Object.assign( {}, Peice.prototype );
ViaData.constructor = ViaData;

/*
class IVIA: public IPEICE
{
public:
	//virtual ~IVIA();
	virtual CTEXTSTR name( void )=0;
	virtual Image GetViaStart( int direction, int scale = 0 )=0;// { return null; }
	virtual Image GetViaEnd( int direction, int scale = 0 )=0;//{ return null; }
	// getviafromto will result in start or end if from or to is NOWHERE respectively
	virtual Image GetViaFromTo( int from, int to, int scale = 0 ){ return null; }

	virtual Image GetViaFill1( int *xofs, int *yofs, int direction, int scale = 0 ){ return null; }
	virtual Image GetViaFill2( int *xofs, int *yofs, int direction, int scale = 0 ){ return null; }
	virtual int Move( void ) { return 0; } // Begin, Start
	virtual int Stop( void ) { return 0; } // end
	PVIA_METHODS via_methods;
};
*/

function IVia( board, name
		  , image// = null
		  , methods// = null
		  , psv
		  ) //: VIA_DATA( board, name, image )
{
	//super( board, name, image );

	this.via_methods = methods || DefaultViaMethods();
	this.psvCreate = psv;
	this.via_master = this;
	this.methods = 

	this.via_methods = methods;
	this.psvCreate = psv;
	this.via_master = this;
	this.methods = methods;
	// anything special? yes.
}

Via.prototype = new ViaData();
Via.prototype.constructor = Via;



export function createVia( board, name //= WIDE("A Peice")
											 , image //= null
											 , methods //= null
											 , psv
											 )
{
	return new Via( board, name, image, methods, psv );
}


